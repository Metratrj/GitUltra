// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod gitultra {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod git {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        pub enum IndexEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct IndexEntry<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for IndexEntry<'a> {
            type Inner = IndexEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> IndexEntry<'a> {
            pub const VT_PATH: flatbuffers::VOffsetT = 4;
            pub const VT_OID: flatbuffers::VOffsetT = 6;
            pub const VT_SIZE: flatbuffers::VOffsetT = 8;
            pub const VT_CTIME: flatbuffers::VOffsetT = 10;
            pub const VT_MTIME: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                IndexEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args IndexEntryArgs<'args>,
            ) -> flatbuffers::WIPOffset<IndexEntry<'bldr>> {
                let mut builder = IndexEntryBuilder::new(_fbb);
                builder.add_mtime(args.mtime);
                builder.add_ctime(args.ctime);
                builder.add_size(args.size);
                if let Some(x) = args.oid {
                    builder.add_oid(x);
                }
                if let Some(x) = args.path {
                    builder.add_path(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn path(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IndexEntry::VT_PATH, None) }
            }
            #[inline]
            pub fn oid(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(IndexEntry::VT_OID, None)
                }
            }
            #[inline]
            pub fn size(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(IndexEntry::VT_SIZE, Some(0)).unwrap() }
            }
            #[inline]
            pub fn ctime(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u64>(IndexEntry::VT_CTIME, Some(0)).unwrap() }
            }
            #[inline]
            pub fn mtime(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u64>(IndexEntry::VT_MTIME, Some(0)).unwrap() }
            }
        }

        impl flatbuffers::Verifiable for IndexEntry<'_> {
            #[inline]
            fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "oid",
                        Self::VT_OID,
                        false,
                    )?
                    .visit_field::<u32>("size", Self::VT_SIZE, false)?
                    .visit_field::<u64>("ctime", Self::VT_CTIME, false)?
                    .visit_field::<u64>("mtime", Self::VT_MTIME, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct IndexEntryArgs<'a> {
            pub path: Option<flatbuffers::WIPOffset<&'a str>>,
            pub oid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
            pub size: u32,
            pub ctime: u64,
            pub mtime: u64,
        }
        impl<'a> Default for IndexEntryArgs<'a> {
            #[inline]
            fn default() -> Self {
                IndexEntryArgs {
                    path: None,
                    oid: None,
                    size: 0,
                    ctime: 0,
                    mtime: 0,
                }
            }
        }

        pub struct IndexEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IndexEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexEntry::VT_PATH, path);
            }
            #[inline]
            pub fn add_oid(&mut self, oid: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IndexEntry::VT_OID, oid);
            }
            #[inline]
            pub fn add_size(&mut self, size: u32) {
                self.fbb_.push_slot::<u32>(IndexEntry::VT_SIZE, size, 0);
            }
            #[inline]
            pub fn add_ctime(&mut self, ctime: u64) {
                self.fbb_.push_slot::<u64>(IndexEntry::VT_CTIME, ctime, 0);
            }
            #[inline]
            pub fn add_mtime(&mut self, mtime: u64) {
                self.fbb_.push_slot::<u64>(IndexEntry::VT_MTIME, mtime, 0);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IndexEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                IndexEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<IndexEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for IndexEntry<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("IndexEntry");
                ds.field("path", &self.path());
                ds.field("oid", &self.oid());
                ds.field("size", &self.size());
                ds.field("ctime", &self.ctime());
                ds.field("mtime", &self.mtime());
                ds.finish()
            }
        }
        pub enum IndexCacheOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct IndexCache<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for IndexCache<'a> {
            type Inner = IndexCache<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> IndexCache<'a> {
            pub const VT_VERSION: flatbuffers::VOffsetT = 4;
            pub const VT_ENTRIES: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                IndexCache { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args IndexCacheArgs<'args>,
            ) -> flatbuffers::WIPOffset<IndexCache<'bldr>> {
                let mut builder = IndexCacheBuilder::new(_fbb);
                if let Some(x) = args.entries {
                    builder.add_entries(x);
                }
                builder.add_version(args.version);
                builder.finish()
            }

            #[inline]
            pub fn version(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(IndexCache::VT_VERSION, Some(0)).unwrap() }
            }
            #[inline]
            pub fn entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IndexEntry<'a>>>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IndexEntry>>,
                    >>(IndexCache::VT_ENTRIES, None)
                }
            }
        }

        impl flatbuffers::Verifiable for IndexCache<'_> {
            #[inline]
            fn run_verifier(v: &mut flatbuffers::Verifier, pos: usize) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_field::<u32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IndexEntry>>>>("entries", Self::VT_ENTRIES, false)?
     .finish();
                Ok(())
            }
        }
        pub struct IndexCacheArgs<'a> {
            pub version: u32,
            pub entries:
                Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IndexEntry<'a>>>>>,
        }
        impl<'a> Default for IndexCacheArgs<'a> {
            #[inline]
            fn default() -> Self {
                IndexCacheArgs {
                    version: 0,
                    entries: None,
                }
            }
        }

        pub struct IndexCacheBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IndexCacheBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_version(&mut self, version: u32) {
                self.fbb_.push_slot::<u32>(IndexCache::VT_VERSION, version, 0);
            }
            #[inline]
            pub fn add_entries(
                &mut self,
                entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<IndexEntry<'b>>>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(IndexCache::VT_ENTRIES, entries);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IndexCacheBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                IndexCacheBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<IndexCache<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for IndexCache<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("IndexCache");
                ds.field("version", &self.version());
                ds.field("entries", &self.entries());
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `IndexCache`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_index_cache_unchecked`.
        pub fn root_as_index_cache(buf: &[u8]) -> Result<IndexCache, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<IndexCache>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `IndexCache` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_index_cache_unchecked`.
        pub fn size_prefixed_root_as_index_cache(buf: &[u8]) -> Result<IndexCache, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<IndexCache>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `IndexCache` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_index_cache_unchecked`.
        pub fn root_as_index_cache_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<IndexCache<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<IndexCache<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `IndexCache` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_index_cache_unchecked`.
        pub fn size_prefixed_root_as_index_cache_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<IndexCache<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<IndexCache<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a IndexCache and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `IndexCache`.
        pub unsafe fn root_as_index_cache_unchecked(buf: &[u8]) -> IndexCache {
            flatbuffers::root_unchecked::<IndexCache>(buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed IndexCache and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `IndexCache`.
        pub unsafe fn size_prefixed_root_as_index_cache_unchecked(buf: &[u8]) -> IndexCache {
            flatbuffers::size_prefixed_root_unchecked::<IndexCache>(buf)
        }
        #[inline]
        pub fn finish_index_cache_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<IndexCache<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_index_cache_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<IndexCache<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod git
} // pub mod gitultra
